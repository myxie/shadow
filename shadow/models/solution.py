# Copyright (C) 2020 RW Bunney

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


class Allocation:
    """
    A simple storage class to save an allocation to a solution
    """

    def __init__(self, task, machine, ast=None, aft=None):
        self.machine = machine
        self.task = task
        self.ast = ast
        self.aft = aft

    def __repr__(self):
        return str(self.task)

    def reset(self):
        self.task.ast = -1
        self.ast = -1
        self.task.aft = -1
        self.aft = -1


class Solution:
    """
    A solution is generated by an algorithm, or a number of solutions are generated
    in the case that we are comparing a population of solutions.
    """

    def __init__(self, machines):
        self.machines = machines
        # Generate a list of allocations for each machine
        self.allocations = {m.id: [] for m in machines}
        self.task_allocations = {}
        self.execution_order = []
        self.makespan = 0

    def add_allocation(self, task, machine, ast=None, aft=None, sort=True):
        a = Allocation(task, machine, ast, aft)
        self.allocations[machine.id].append(a)
        if sort:
            self.allocations[machine.id].sort(
                key=lambda alloc: alloc.ast
            )
        self.task_allocations[task] = a
        self.execution_order.append(a)
        if sort:
            self.execution_order.sort(key=lambda alloc: alloc.ast)
        self.makespan = self.execution_order[-1].aft

    def list_machine_allocations(self, machine):
        """
        Returns a sorted list of the current Allocation objects being stored on
        the machine
        :param machine: The String name of the machine
        :return:
        """
        self.allocations[machine.id].sort(
            key=lambda alloc: alloc.task.ast
        )
        return self.allocations[machine.id]

    def task_machine_pairs(self):
        pairs = []
        for machine in self.allocations:
            pairs.append([(machine, alloc.task.tid) for alloc in self.allocations[machine]])
        return pairs

    def latest_allocation_on_machine(self, machine):
        final = len(self.allocations[machine.id])
        if final == 0:
            return None
        else:
            last_alloc = self.allocations[machine.id][final - 1]
            return last_alloc

    def list_all_allocations(self):
        return self.allocations

    def pretty_print_allocation(self):
        """
        Generate a string-formatted version of the solutions allocated,
        for use in command line reporting.
        Returns
        -------

        """
        ret_str = ''
        if self.allocations:
            # TODO logic
            return str
        else:
            return None

    def find_alloc(self, task):
        pass

    def remove_allocation(self, tid, m):
        pass
